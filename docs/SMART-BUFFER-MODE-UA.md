# Розумне керування буфером (Live smart) та Local VOD

Цей документ простими словами пояснює, як програвач тепер вирішує, коли:
- пришвидшуватися,
- йти у звичному темпі,
- або сповільнюватися

однаково для:
- Live «smart» (планування перезавантаження плейлиста), і
- Local VOD (постановка сегментів у чергу).

Логіка в обох режимах узгоджена, а логи виглядають подібно.

---

## Головні ідеї простими словами

- «Тривалість сегмента» (seg) — це тривалість одного медіа-фрагмента. Ваш природний «метроном».
- «Буфер наперед» (buf) — скільки вже доставленого часу відтворення у вас в запасі (у секундах) відносно реального часу.
- «Ємність» (cap) — цільовий буфер, до якого ми прагнемо. Він базується на типовій тривалості сегмента, помноженій на коефіцієнт (для Live і VOD коефіцієнти різні).
- «Смуга» (band) — невеликий запас навколо типової тривалості сегмента (щоби стабільніше обирати режим).

Ми постійно дивимося:
- Скільки у нас буфера (buf),
- Яка наша ціль (cap),
- І яка типова тривалість одного сегмента (seg, і band).

З цього обираємо режим:
- growth — пришвидшуємося, якщо буфер замалий
- normal — тримаємо звичний темп
- slow — сповільнюємося, якщо буфер завеликий

і плануємо наступну паузу очікування.

---

## Спільні терміни

- seg: базова тривалість сегмента (секунди)
  - Live smart: тривалість останнього сегмента.
  - Local VOD: тривалість останнього сегмента (з легкою протидією викидам).
- band: типова тривалість сегмента, що використовується як «смуга» безпеки
  - Live smart: середнє по недавніх тривалостях.
  - Local VOD: «робастне» середнє по недавніх тривалостях (медіана впереміш із верхнім перцентилем), або просте середнє, якщо історії замало.
- buf: відтворюваний буфер наперед (секунди). Це доставлений медіачас мінус минулий реальний час. Може бути > cap.
- cap: цільовий буфер (секунди)
  - Live: середня тривалість сегмента × live_buffer_mult
  - VOD: робастне середнє × vod_buffer_mult
- Мінімальна пауза очікування: ніколи не менше 1.00 с, щоб не опитувати занадто часто.

---

## Режими: коли пришвидшуватися, йти нормально або сповільнюватися?

Те саме правило для Live smart і Local VOD:

- slow — якщо буфер «суттєво вище» цілі:
  - buf > cap + band (і це не самий початок)
- growth — якщо буфер «надто малий»:
  - buf < seg АБО buf < cap − band (і це не самий початок)
- normal — інакше

Стартова «поблажка»: на самому початку перше планування вважаємо normal, щоб уникати різких рухів.

Чому дві перевірки для growth?
- buf < seg — якщо буфер менший за один сегмент, це занадто мало → пришвидшуємося.
- buf < cap − band — навіть якщо буфер трохи більший за один сегмент, але помітно нижче цілі (cap), теж пришвидшуємося.

---

## Скільки чекати до наступного кроку (темп)

Однаковий підхід в обох режимах:

- normal: wait = seg
- growth (пришвидшуємося, коли буфер низький):
  - очікування масштабується від заповнення: wait ≈ seg × clamp(buf/cap, 0..1), але не менше 1 с
  - Що нижчий буфер відносно цілі, то коротше очікування
- slow (сповільнюємося, коли буфер високий):
  - wait ≈ seg × max(1, buf/cap), обмежено cap і не менше 1 с
  - Що вищий буфер відносно цілі, то довше чекаємо, але максимум — cap

Іншими словами:
- Якщо буфер низький — чекаємо менше за тривалість одного сегмента.
- Якщо буфер переповнений — чекаємо довше, ніж один сегмент (але не більше cap).
- Якщо «все гаразд» — чекаємо рівно один сегмент.

---

## Pre-grace: коротка «пауза-грейс», щоб впіймати майже завершені сегменти

Щоб планувати точніше, перед розрахунком наступної паузи робимо коротку «паузу-грейс»:
- Якщо сегмент щойно завершився або ось-ось завершиться (є внутрішній сигнал від завантажувача), ми трохи зачекаємо (в розумних межах), щоб облік буфера включав ці завершення.
- Це робить вибір режиму та час очікування стабільнішими і точнішими.
- Верхня межа «грейса» обмежена і може трохи розтягуватися за оцінкою швидкості завантаження.

Це працює як для:
- Live smart (планування перезавантаження плейлиста),
- Local VOD (планування постановки сегментів у чергу).

---

## Що видно в логах

Показуємо:
- запланований час очікування,
- seg (базову тривалість сегмента),
- buf/cap (поточний буфер і ціль),
- thr (throttle) — різницю із seg, зі знаком плюс або мінус,
- mode (growth/normal/slow).

Приклади:

Local VOD (темп постановки у чергу):
- «growth» із від’ємним throttle (пришвидшуємося)
  - << Local VOD: next enqueue adaptive in 0.85s (seg=6.00s buf=2.0s/18.0s) thr=-5.15s fill=0.11 mode=growth)
- «normal» (рівно темп сегмента, thr=+0.00s)
  - << Local VOD: next enqueue adaptive in 6.00s (seg=6.00s buf=10.5s/18.0s) thr=+0.00s fill=0.58 mode=normal)
- «slow» із додатним throttle (сповільнюємося)
  - << Local VOD: next enqueue adaptive in 10.50s (seg=6.00s buf=25.0s/18.0s) thr=+4.50s fill=1.39 mode=slow)

Live smart (планування перезавантаження плейлиста):
- << Planning Reload [smart] in 1.20s: (seg=6.00s buf=2.0s/12.0s) thr=-4.80s fill=0.17 mode=growth)
- << Planning Reload [smart] in 6.00s: (seg=6.00s buf=6.1s/12.0s) thr=+0.00s fill=0.51 mode=normal)
- << Planning Reload [smart] in 10.00s: (seg=6.00s buf=20.0s/12.0s) thr=+4.00s fill=1.67 mode=slow)

Нотатки:
- thr показує відхилення від «крок по одному сегменту»:
  - thr < 0 — ідемо швидше за сегмент (пришвидшуємося),
  - thr > 0 — ідемо повільніше (гальмуємо).

---

## Корисні налаштування

- «HLS Live buffer multiplier» (Live smart): цільовий буфер = середня_тривалість_сегмента × live_buffer_mult
  - Типове значення: 3.0 (приблизно три сегменти наперед)
- «HLS VOD buffer multiplier» (Local VOD): цільовий буфер = робастне_середнє × vod_buffer_mult
  - Типове значення: 3.0 (приблизно три «типові» сегменти наперед)
- plan_completion_grace_max: верхня межа коротких «грейсів», коли чекаємо близьке завершення сегмента
- Мінімальна пауза очікування: 1.00 с (жорстко), щоб не прокидатися надто часто
- Вікна згладжування буфера:
  - Live: використовує середню тривалість недавніх сегментів для band/cap
  - VOD: використовує «робастне» середнє (суміш медіани та верхнього перцентиля), щоб не піддаватися викидам

Додатково для VOD (працює автоматично):
- Детектор «серії повільних» завантажень: якщо сегменти стабільно качаються повільніше за свою тривалість, вмикаємо короткий «стабільний режим» на кілька сегментів.
- Легка протидія викидам: якщо один сегмент різко вибивається, ми не реагуємо надто агресивно.

---

## FAQ

П: Чому buf може бути більшим за cap?
- Нормально деякий час бути вище цілі. У «slow» ми м’яко даємо буферу «стікати», не виходячи за максимум очікування cap.

П: Чому інколи з’являються маленькі додаткові паузи?
- Це «pre-grace» — короткі очікування, щоб впіймати майже завершені сегменти і точніше порахувати буфер перед рішенням.

П: Якщо мережа «смикається»?
- Система адаптується: коли сегменти завантажуються довше, сигнал буфера і детектор «повільних серій» природно тримають темп стабільним.

---

## Одним рядком

І Live smart, і Local VOD тепер використовують одне просте правило:
- Низький буфер → пришвидшуємося
- Нормальний буфер → звичний темп
- Високий буфер → сповільнюємося
із зрозумілими логами, де видно відхилення від «по одному сегменту за крок» (thr=±...s).
