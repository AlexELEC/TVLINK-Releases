# Gap threshold: когда и почему мы останавливаемся раньше

В коде используются два связанных механизма, которые помогают вовремя завершать поток и не «висеть» бесконечно, когда:
- Загрузка сегментов идет слишком медленно (застревание).
- Плейлист перестал пополняться.
- Буфер многократно “проседает” или надолго становится отрицательным.

Механизмы:

- Smart / Local VOD: `_smart_threshold_reached()` — «умные» многошаговые правила (буфер + тайминги сегментов).
- Остальные режимы (segment / targetduration / constant): `_segment_queue_timing_threshold_reached()` — простое правило «слишком долго нет новых сегментов».

Ниже — простое описание без формул.

---

## Что такое «буфер» и как его понимать

- Буфер (в секундах) ≈ (доставлено воспроизводимого времени) − (настенное время с начала воспроизведения).
- Положительный буфер: «есть запас» — идём впереди.
- Отрицательный буфер: «отстаём» — не успеваем догружать.

Примеры в логах: `buf=12.3s` или `buf=-0.5s`.

---

## Smart (Live smart) и Local VOD: правила остановки

Проверка `_smart_threshold_reached()` вызывается:
- Сразу после постановки новых сегментов (даже если уже что-то добавили — `queued == True`).
- В Local VOD — также в паузах между пакетными добавлениями.
- Когда в текущей итерации ничего не добавлено.

“elapsed” для сегмента считается от старта HTTP-запроса по монотонным часам и совпадает по шкале с логом:
`+ Segment N complete (time=...)`
Это гарантирует согласованность принятия решений с видимыми логами.

Всего ЧЕТЫРЕ правила (по порядку). Первое сработавшее — останавливает поток.

### 1) Просроченный сегмент + отрицательный буфер → СТОП
- Если хотя бы один сегмент «в полёте» скачивается дольше своего EXTINF и текущий буфер уже < 0 — мгновенная остановка.
- Логи:
  - Продолжаем (буфер положительный):  
    `> Segment N exceeded duration but buffer still positive: elapsed=... > dur=...; buf=...s. Continue...`
  - Останавливаемся (буфер отрицательный):  
    `=> Segment N exceeded its duration while downloading: elapsed=... > dur=...; buf=...s (<0). Stopping...`

### 2) Повторные входы в отрицательный буфер в пределах окна → СТОП
- Отслеживается каждое «переходное» событие: буфер был ≥0 и снова стал <0.
- Ведётся скользящее окно (по умолчанию 60s) с этими событиями.
- Если их число достигает лимита (по умолчанию 3) внутри окна — остановка.
- Положительные промежутки внутри окна НЕ обнуляют счётчик; сброс только по истечению окна (если порог не достигнут).
- Логи:
  - Каждый новый вход:  
    `=> Negative buffer event #2 in current 60s window`
  - Истёкшее окно без достижения порога:  
    `=> Negative buffer window expired (60s) without threshold; counter reset.`
  - Порог достигнут:  
    `=> Buffer entered negative state 3 times within 60s window. Stopping...`

### 3) GAP-правило: дефицит буфера > длины последнего сегмента (после того, как буфер уже бывал ≥0) → СТОП
- Активируется только если буфер ранее хотя бы раз был положительным.
- Если буфер отрицательный и |buf| больше «оценки длины последнего сегмента» — остановка.
- Пример: `buf=-5.01s`, “последний сегмент” ≈ `5.00s` → стоп.
- Лог:  
  `=> Buffer deficit exceeded last segment length: |buf|=5.01s > last_seg=5.00s. Stopping...`

Приоритет оценки “длины последнего сегмента”:
1. EXTINF последнего сегмента текущего плейлиста.
2. Последняя наблюдавшаяся длительность (recent).
3. Smart-база (baseline).
4. targetduration плейлиста.
5. Минимальный пол (MIN_RELOAD_FLOOR = 1.00s).

### 4) Непрерывно отрицательный буфер дольше порога очереди → СТОП
- Если буфер остаётся <0 непрерывно дольше «порогового времени очереди» — остановка.
- «Пороговое время очереди» рассчитывается точно как в `_segment_queue_timing_threshold_reached()` (targetduration или среднее последних ~3 EXTINF, но не ниже минимума, умноженное на `hls-segment-queue-threshold`).
- Если `hls-segment-queue-threshold <= 0`, правило отключено.
- Лог:  
  `=> Buffer stayed negative for more than X.XXs. Stopping...`

Технически:
- Фиксируется момент первого ухода в минус и сбрасывается при возврате в неотрицательную область.

---

## Остальные режимы (segment / targetduration / constant)

Если Smart / Local VOD не активны, остаётся только таймер `_segment_queue_timing_threshold_reached()`:

- Базовая длительность = максимум (фиксированный минимум 5s, targetduration, среднее последних до 3 EXTINF).
- Умножается на `hls-segment-queue-threshold`.
- Если с последнего добавления прошло больше порога — остановка.
- Лог:  
  `=> No new segments in playlist for more than X.XXs. Stopping...`

Фактор = 0 → правило отключено.

---

## Сравнение режимов

| Режим | Планирование | Правила остановки |
|-------|--------------|-------------------|
| Live smart | Адаптивное по буферу | 1) просрочка+минус; 2) повторные отрицательные входы; 3) GAP (|buf|>длина); 4) долго минусовой |
| Local VOD | Пакетная подача без reload между сегментами в пакете | Те же четыре правила (проверяются и во время ожиданий) |
| segment / targetduration / constant | Простая/фиксированная логика | Только «нет новых сегментов» |

---

## Примеры логов

Просрочка, буфер положительный (продолжаем):
```
> Segment 935641 exceeded duration but buffer still positive: elapsed=10.53s > dur=10.43s; buf=1.3s. Continue...
```

Просрочка + отрицательный буфер (стоп):
```
=> Segment 935642 exceeded its duration while downloading: elapsed=22.44s > dur=10.43s; buf=-0.5s (<0). Stopping...
```

Повторные входы в минус (развитие и срабатывание порога):
```
=> Negative buffer event #1 in current 60s window
=> Negative buffer event #2 in current 60s window
=> Buffer entered negative state 3 times within 60s window. Stopping...
```

GAP-правило:
```
=> Buffer deficit exceeded last segment length: |buf|=5.01s > last_seg=5.00s. Stopping...
```

Длительно отрицательный:
```
=> Buffer stayed negative for more than 15.00s. Stopping...
```

Не smart-режим (нет новых сегментов):
```
=> No new segments in playlist for more than 15.00s. Stopping...
```

Окно истекло без порога:
```
=> Negative buffer window expired (60s) without threshold; counter reset.
```

---

## Почему «elapsed» и «time» согласованы

- `elapsed` в предупреждениях и `time=...` в завершении сегмента используют одну монотонную шкалу (от старта HTTP-запроса).
- Предупреждение может выйти до финального лога — поэтому его `elapsed` иногда чуть меньше финального `time=...`, но база одна.

---

## Практическая интерпретация

| Симптом | Вероятная причина | Действие |
|---------|-------------------|----------|
| Частые срабатывания правила 1 | CDN / ограничение скорости | Проверить сеть, снизить битрейт |
| Частые правила 2 | Рваные провалы в производстве/доставке | Увеличить целевой буфер или проверить источник |
| Правило 3 | Устойчивое запаздывание после периода нормальной работы | Проверить задержку генерации сегментов |
| Правило 4 | Непрерывное голодание | Убедиться в живости потока или переключиться |
| “No new segments” | Плейлист стоит/закончился | Проверить источник или завершение намеренное |

---

## Основные настройки

- `hls-playlist-reload-time=smart` — включает smart-логику.
- `hls-segment-queue-threshold` — включает порог тишины и непрерывно-отрицательное правило.
- `live-buffer-mult`, `vod-buffer-mult` — размер целевого буфера.
- `vod-start`, `vod-process`, `vod-queue-step` — пакетирование в Local VOD.

---

## Итог

Четыре “умных” правила предотвращают бессмысленное ожидание при реальных зависаниях и деградациях. Простые режимы сохраняют только контроль «нет новых сегментов». Логи дают точную причину остановки — по ним легко корректировать источник или настройки.

Стабильных вам запусков и предсказуемых остановок!