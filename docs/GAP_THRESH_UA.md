# Gap threshold: коли і чому ми зупиняємося раніше

У коді діють два пов’язані механізми, які допомагають вчасно завершити потік і не “висіти” нескінченно, коли:
- Завантаження сегментів надто повільне (застрягання).
- Плейлист перестав оновлюватися.
- Буфер багаторазово провалюється або довго залишається від’ємним.

Механізми:

- Smart / Local VOD: `_smart_threshold_reached()` — “розумні” багатокрокові правила (буфер + таймінги сегментів).
- Інші режими (segment / targetduration / constant): `_segment_queue_timing_threshold_reached()` — просте правило «надто довго немає нових сегментів».

Нижче — спрощене пояснення без формул.

---

## Що таке «буфер» і як його читати

- Буфер (секунди) ≈ (доставлено програного часу) − (настінний час від старту).
- Додатний буфер: маємо запас.
- Від’ємний буфер: відстаємо.

Приклади в логах: `buf=12.3s` або `buf=-0.5s`.

---

## Smart (Live smart) і Local VOD: правила зупинки

Перевірка `_smart_threshold_reached()` виконується:
- Одразу після постановки нових сегментів (навіть якщо вже були — `queued == True`).
- У Local VOD також під час пауз між пакетними додаваннями.
- Коли в поточному циклі нічого не додано.

“elapsed” рахується від початку HTTP-запиту монотонним годинником і узгоджений із логом:
`+ Segment N complete (time=...)`

Є ЧОТИРИ правила (послідовно). Перше, що спрацює, — зупиняє потік.

### 1) Прострочений сегмент + від’ємний буфер → СТОП
- Якщо хоча б один сегмент завантажується довше свого EXTINF і буфер уже < 0 — негайна зупинка.
- Логи:
  - Продовжуємо (буфер додатний):  
    `> Segment N exceeded duration but buffer still positive: elapsed=... > dur=...; buf=...s. Continue...`
  - Зупинка (буфер від’ємний):  
    `=> Segment N exceeded its duration while downloading: elapsed=... > dur=...; buf=...s (<0). Stopping...`

### 2) Повторні входи у від’ємний буфер в межах вікна → СТОП
- Фіксується кожен перехід: буфер був ≥0 і знову став <0.
- Веде́ться ковзне вікно (типово 60s) таких подій.
- Якщо кількість досягає ліміту (типово 3) у межах вікна — зупинка.
- Додатні ділянки усередині вікна НЕ обнуляють лічильник; лише закінчення вікна (якщо поріг не досягнуто).
- Логи:
  - Новий вхід:  
    `=> Negative buffer event #2 in current 60s window`
  - Вікно минуло без спрацювання:  
    `=> Negative buffer window expired (60s) without threshold; counter reset.`
  - Поріг досягнуто:  
    `=> Buffer entered negative state 3 times within 60s window. Stopping...`

### 3) GAP-правило: дефіцит буфера > довжини останнього сегмента (після того як буфер вже був ≥0) → СТОП
- Активне лише якщо раніше буфер був додатним.
- Якщо буфер <0 і |buf| > оцінки довжини останнього сегмента — зупинка.
- Приклад: `buf=-5.01s`, останній ≈ `5.00s` → стоп.
- Лог:  
  `=> Buffer deficit exceeded last segment length: |buf|=5.01s > last_seg=5.00s. Stopping...`

Пріоритет оцінки довжини:
1. EXTINF останнього сегмента.
2. Остання спостережена тривалість.
3. Smart-база.
4. targetduration.
5. Мінімальний пол (MIN_RELOAD_FLOOR = 1.00s).

### 4) Безперервно від’ємний буфер довше порогового часу → СТОП
- Якщо буфер залишався <0 безперервно довше «порогового часу черги» — зупинка.
- Пороговий час обчислюється так само, як у `_segment_queue_timing_threshold_reached()` (targetduration або середнє останніх ~3 EXTINF, не нижче мінімуму, множиться на `hls-segment-queue-threshold`).
- Якщо `hls-segment-queue-threshold <= 0`, правило вимкнено.
- Лог:  
  `=> Buffer stayed negative for more than X.XXs. Stopping...`

Технічне:
- Фіксується момент першого занурення <0 і скидається при поверненні в ≥0.

---

## Інші режими (segment / targetduration / constant)

Якщо Smart / Local VOD неактивні, діє лише `_segment_queue_timing_threshold_reached()`:

- База = max(мінімум 5s, targetduration, середнє останніх до 3 EXTINF).
- Множимо на `hls-segment-queue-threshold`.
- Нема нових сегментів довше порога → зупинка.
- Лог:  
  `=> No new segments in playlist for more than X.XXs. Stopping...`

Фактор = 0 → вимкнено.

---

## Порівняння режимів

| Режим | Планування | Правила зупинки |
|-------|------------|-----------------|
| Live smart | Адаптивне за буфером | 1) прострочка+мінус; 2) повторні негативні входи; 3) GAP; 4) довга безперервна від’ємність |
| Local VOD | Пакетне додавання (без reload між сегментами пакету) | Ті ж чотири правила (перевірки і під час очікування) |
| segment / targetduration / constant | Проста/фіксована логіка | Лише «немає нових сегментів» |

---

## Приклади логів

Прострочка, буфер додатний:
```
> Segment 935641 exceeded duration but buffer still positive: elapsed=10.53s > dur=10.43s; buf=1.3s. Continue...
```

Прострочка + від’ємний:
```
=> Segment 935642 exceeded its duration while downloading: elapsed=22.44s > dur=10.43s; buf=-0.5s (<0). Stopping...
```

Повторні входи у від’ємний буфер:
```
=> Negative buffer event #1 in current 60s window
=> Negative buffer event #2 in current 60s window
=> Buffer entered negative state 3 times within 60s window. Stopping...
```

GAP-правило:
```
=> Buffer deficit exceeded last segment length: |buf|=5.01s > last_seg=5.00s. Stopping...
```

Довго від’ємний:
```
=> Buffer stayed negative for more than 15.00s. Stopping...
```

Не smart-режим:
```
=> No new segments in playlist for more than 15.00s. Stopping...
```

Закінчення вікна без порога:
```
=> Negative buffer window expired (60s) without threshold; counter reset.
```

---

## Чому «elapsed» і «time» узгоджені

- `elapsed` у попередженнях та `time=` у завершенні сегмента мають одну монотонну шкалу.
- Попередження може з’явитись раніше — тому його `elapsed` трохи менше фінального `time=...`, але база однакова.

---

## Практична інтерпретація

| Симптом | Ймовірна причина | Дія |
|---------|------------------|-----|
| Часті правила 1 | CDN / обмеження швидкості | Перевірити мережу, зменшити бітрейт |
| Часті правила 2 | Рвані короткі провали | Збільшити буфер або перевірити джерело |
| Правило 3 | Стійкий лаг після нормальної роботи | Перевірити затримку генерації сегментів |
| Правило 4 | Постійне голодування | Переконатися, що джерело активне |
| “No new segments” | Плейлист стоїть або завершився | Перевірити джерело / підтвердити завершення |

---

## Основні налаштування

- `hls-playlist-reload-time=smart` — ввімкнути smart.
- `hls-segment-queue-threshold` — поріг тиші + правило безперервної негативності.
- `live-buffer-mult`, `vod-buffer-mult` — розмір цільового буфера.
- `vod-start`, `vod-process`, `vod-queue-step` — пакетування у Local VOD.

---

## Підсумок

Чотири “розумні” правила зупиняють потік без зайвого очікування при реальних збоях. У простих режимах працює лише таймаут відсутності нових сегментів. Логи прозоро показують точну причину — легко коригувати налаштування або джерело.

Нехай ваші стріми завершуються передбачувано!