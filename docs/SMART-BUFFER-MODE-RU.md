# Управление темпом на основе буфера (Live smart) и Local VOD

Этот документ простыми словами объясняет, как плеер теперь решает, когда:
- ускоряться,
- идти в обычном темпе,
- или замедляться

одинаково для:
- Live «smart» (планирование перезагрузки плейлиста), и
- Local VOD (постановка сегментов в очередь).

Логика в обоих режимах согласована, и логи выглядят похоже.

---

## Главные идеи простыми словами

- «Длительность сегмента» (seg) — это длительность одного медиа-куска. Это ваш естественный «метроном».
- «Буфер вперёд» (buf) — сколько уже доставленного времени воспроизведения у вас в запасе (в секундах) относительно реального времени.
- «Вместимость» (cap) — целевой буфер, к которому мы стремимся. Он считается на основе типичной длительности сегмента, умноженной на коэффициент (для Live и VOD коэффициенты разные).
- «Пояс» (band) — небольшой запас вокруг типичной длительности сегмента (используется, чтобы устойчиво выбирать режим).

Мы постоянно смотрим:
- Сколько у нас буфера (buf),
- Какой у нас целевой уровень (cap),
- И какова типичная длительность одного сегмента (seg, и band).

Из этого выбираем режим:
- growth — ускоряемся, если буфер слишком мал
- normal — держим обычный темп
- slow — замедляемся, если буфер слишком большой

и планируем следующую паузу ожидания.

---

## Общие термины

- seg: базовая длительность сегмента (в секундах)
  - Live smart: длительность последнего сегмента.
  - Local VOD: длительность последнего сегмента (с лёгкой защитой от выбросов).
- band: типичная длительность сегмента, используемая как «пояс» безопасности
  - Live smart: среднее по недавним длительностям.
  - Local VOD: «робастное» среднее по недавним длительностям (медиана в смеси с верхним перцентилем), либо простое среднее, если истории мало.
- buf: проигрываемый буфер вперёд (секунды). Это доставленное медиавремя минус прошедшее реальное время. Может быть > cap.
- cap: целевой буфер (секунды)
  - Live: средняя длительность сегмента × live_buffer_mult
  - VOD: робастное среднее × vod_buffer_mult
- Минимальный пол (минимальная пауза): мы никогда не ждём меньше 1.00 сек, чтобы не опрашивать слишком часто.

---

## Режимы: когда ускоряться, идти обычно или замедляться?

Одно и то же правило для Live smart и Local VOD:

- slow — если буфер «сильно выше» цели:
  - buf > cap + band (и это не самые первые мгновения старта)
- growth — если буфер «слишком мал»:
  - buf < seg ИЛИ buf < cap − band (и это не самые первые мгновения старта)
- normal — иначе

Стартовая «поблажка»: в самом начале первую планировку считаем normal, чтобы не дергаться слишком резко.

Почему две проверки для growth?
- buf < seg — если буфер меньше одного сегмента, это слишком «худо» → ускоряемся.
- buf < cap − band — даже если буфер чуть больше одного сегмента, но заметно ниже цели (cap), тоже ускоряемся.

---

## Сколько ждать до следующего шага (темп)

Одинаковый подход в обоих режимах:

- normal: wait = seg
- growth (ускоряемся при низком буфере):
  - ожидание масштабируется от заполнения: wait ≈ seg × clamp(buf/cap, 0..1), но не меньше 1 сек
  - Чем ниже буфер относительно цели, тем короче ожидание
- slow (замедляемся при большом буфере):
  - wait ≈ seg × max(1, buf/cap), но не больше cap и не меньше 1 сек
  - Чем выше буфер относительно цели, тем дольше ждём, но максимум — cap

Иными словами:
- Если буфер низкий — ждём меньше длительности одного сегмента.
- Если буфер переполнен — ждём дольше, чем один сегмент (но не более cap).
- Если «всё в порядке» — ждём ровно как один сегмент.

---

## Pre-grace: короткая «пауза-фора» для захвата почти завершённых сегментов

Чтобы точнее планировать, прямо перед расчётом следующей паузы мы делаем короткую «паузу-фору»:
- Если сегмент только что завершился или вот-вот завершится (есть внутренний сигнал от загрузчика), мы слегка подождём (в разумных пределах), чтобы учесть эти завершения в буфере.
- Так режим и время ожидания получаются устойчивее и точнее.
- Верхняя граница «фор» ограничена (plan_completion_grace_max) и может чуть растягиваться по оценке скорости загрузки.

Это работает и для:
- Live smart (планирование перезагрузки плейлиста),
- Local VOD (планирование постановки сегментов в очередь).

---

## Что видно в логах

Показываем:
- запланированную паузу ожидания,
- seg (базовую длительность сегмента),
- buf/cap (текущий буфер и цель),
- thr (throttle) — разницу с seg, со знаком плюс или минус,
- mode (growth/normal/slow).

Примеры:

Local VOD (темп постановки в очередь):
- «growth» с отрицательным throttle (ускоряемся)
  - << Local VOD: next enqueue adaptive in 0.85s (seg=6.00s buf=2.0s/18.0s) thr=-5.15s fill=0.11 mode=growth)
- «normal» (ровно темп сегмента, thr=+0.00s)
  - << Local VOD: next enqueue adaptive in 6.00s (seg=6.00s buf=10.5s/18.0s) thr=+0.00s fill=0.58 mode=normal)
- «slow» с положительным throttle (замедляемся)
  - << Local VOD: next enqueue adaptive in 10.50s (seg=6.00s buf=25.0s/18.0s) thr=+4.50s fill=1.39 mode=slow)

Live smart (планирование перезагрузки плейлиста):
- << Planning Reload [smart] in 1.20s: (seg=6.00s buf=2.0s/12.0s) thr=-4.80s fill=0.17 mode=growth)
- << Planning Reload [smart] in 6.00s: (seg=6.00s buf=6.1s/12.0s) thr=+0.00s fill=0.51 mode=normal)
- << Planning Reload [smart] in 10.00s: (seg=6.00s buf=20.0s/12.0s) thr=+4.00s fill=1.67 mode=slow)

Заметки:
- thr показывает отклонение от «шагать по одному сегменту»:
  - thr < 0 — идём быстрее сегмента (ускоряемся),
  - thr > 0 — идём медленнее (тормозим).

---

## Полезные настройки

- «HLS Live buffer multiplier» (Live smart): целевой буфер = средняя_длительность_сегмента × live_buffer_mult
  - Типичное значение по умолчанию: 3.0 (около трёх сегментов вперёд)
- «HLS VOD buffer multiplier» (Local VOD): целевой буфер = робастное_среднее × vod_buffer_mult
  - Типичное значение по умолчанию: 3.0 (около трёх «типичных» сегментов вперёд)
- plan_completion_grace_max: верхняя граница коротких «фор», когда ждём близкое завершение сегмента
- Минимальная пауза ожидания: 1.00 сек (жёстко), чтобы не просыпаться слишком часто
- Окна сглаживания буфера:
  - Live: использует среднюю длительность недавних сегментов для band/cap
  - VOD: использует «робастное» среднее (смешение медианы и верхнего перцентиля), чтобы не вестись на выбросы

Дополнительно для VOD (работает автоматически):
- Детектор «серии медленных» загрузок: если сегменты стабильно качаются медленнее своей длительности, включаем короткий «устойчивый режим» на несколько сегментов.
- Лёгкая защита от выбросов: если один сегмент резко выбивается, мы не переусердствуем с реакцией.

---

## FAQ

В: Почему buf может быть больше cap?
- Нормально какое-то время быть выше цели. В «slow» мы мягко даём буферу «стечь», не выходя за максимум ожидания cap.

В: Почему иногда есть маленькие дополнительные паузы?
- Это «pre-grace» — короткие ожидания, чтобы поймать вот-вот завершающиеся сегменты и посчитать буфер точнее перед решением.

В: А если сеть «плавает»?
- Система адаптируется: когда сегменты скачиваются дольше, сам сигнал буфера и детектор «медленных серий» помогают держать темп стабильным.

---

## Одной строкой

И Live smart, и Local VOD теперь используют одно простое правило:
- Низкий буфер → ускоряемся
- Нормальный буфер → обычный темп
- Высокий буфер → замедляемся
с понятными логами, где видно отклонение от «по одному сегменту за шаг» (thr=±...s).
