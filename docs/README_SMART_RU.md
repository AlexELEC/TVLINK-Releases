# Smart Live и Local VOD режимы + Логика Gap/Threshold (Пользовательское руководство)

Это руководство описывает два улучшенных режима управления воспроизведением (Smart Live и Local VOD), а также логику остановки по разрывам/порогам и две функции работы соединений. Текст рассчитан на практических операторов (без сложных формул). Вы узнаете:
- Зачем нужны эти режимы и их преимущества.
- Как принимаются адаптивные решения по времени опроса и буферизации.
- Что означают строки логов (как понять поведение).
- Когда и почему поток останавливается раньше (защитные пороги).
- Что делают “Закрывать соединение сегмента” и “Асинхронное закрытие”.

---

## 1. Smart Live режим

### 1.1. Назначение и выгоды
Обычный HLS-опрос использует фиксированные или упрощённые интервалы (например targetduration). При нестабильной сети или неравномерной генерации сегментов это приводит к:
- Чрезмерным запросам (пустая нагрузка).
- Недостаточному опросу (подbufferивание / фризы).
- Медленной реакции на сбои.

Smart Live (через `hls-playlist-reload-time=smart`) адаптирует частоту обновления плейлиста по фактическому “буферу воспроизведения” — сколько секунд контента уже загружено вперёд относительно реального времени. Это:
- Ускоряет опрос при низком буфере (меньше фризов).
- Замедляет при полном буфере (меньше нагрузки).
- Использует короткие “grace” паузы, чтобы дождаться завершающихся сегментов перед новым планированием.
- Раннее останавливает поток при реальных зависаниях (негативный буфер, застопоренные сегменты), вместо бесконечного ожидания.

### 1.2. Основные идеи (простыми словами)
- “Буфер вперёд” = секунд загруженного, но ещё не «проигранного» контента.
- “Целевая ёмкость” высчитывается по средней длительности сегментов и множителю (`hls-live-buffer-mult`) — по сути “безопасная подушка”.
- Режимы:
  - GROWTH: буфер низкий → чаще перезагружаем плейлист.
  - NORMAL: буфер нормальный → опрос примерно раз в длину сегмента.
  - SLOW: буфер избыточный → удлиняем паузы.
- Короткие “grace” задержки (до ~1с) вставляются, если сегменты почти докачались — чтобы не перезагружать слишком рано.

Настраивать формулы не нужно — только общие параметры (`live-buffer-mult` или смена режима перезагрузки).

### 1.3. Важные опции (Live)
- `hls-playlist-reload-time=smart` — включает Smart Live режим.
- `hls-live-buffer-mult` — множитель целевого буфера (около 3× средней длины сегмента).
- `hls-segment-queue-threshold` — фактор порога “тишины” (также используется в одной из smart-проверок).
- `hls-live-edge` — начальная позиция относительно конца live потока.
- `hls-live-restart` — принудительный старт с начала, если применимо.

### 1.4. Защитные условия (Smart)
Smart может прервать поток (это защита, а не сбой), если:
1. Время загрузки сегмента превысило его собственную длительность И буфер стал отрицательным.
2. Буфер несколько раз уходит в минус в скользящем окне (по умолчанию: 3 отрицательных входа за 60с).
3. Дефицит буфера по абсолютному значению превышает длину последнего сегмента.
4. Буфер остаётся непрерывно отрицательным дольше вычисленного порога (использует логику gap).

### 1.5. Примеры логов (Smart Live)
- `- Adding segment N to queue` — сегмент поставлен в очередь.
- `+ Segment N complete (time=...ms retries=R)` — сегмент загружен (R — кол-во частичных повторов).
- `<< Planning Reload [smart] in X.XXs ... mode=growth|normal|slow` — план следующего опроса.
- `>> Reloading Playlist [smart]: base=... planned=... | waited=...` — фактическая перезагрузка.
- `LARGE JUMP: skipped ... segments` — обнаружен скачок нумерации, статистики сброшены.
- `Negative buffer event #K` — буфер снова ушёл в минус.
- `Segment N exceeded its duration while downloading ... Stopping...` — защитная остановка.
- `Buffer deficit exceeded last segment length ... Stopping...`
- `Buffer stayed negative for more than Ts. Stopping...`

### 1.6. Частичные дозагрузки
При обрывах:
- `Partial/incomplete segment N ... retrying...`
Автоматически перезапрашивает (с возможным Range-дозапросом) до 2 дополнительных попыток.

---

## 2. Local VOD режим

### 2.1. Назначение и выгоды
Некоторые плейлисты напоминают “скользящее” окно (catch-up/timeshift) или конечный список сегментов. Local VOD активируется при типе VOD или наличии `#EXT-X-ENDLIST` (или распознанных шаблонах catch-up). Он:
- Добавляет сегменты партиями (batch) из текущего окна.
- Адаптирует паузы между партиями по скорости загрузки и заполнению буфера.
- Переходит к следующему окну (формирует новый URL) при завершении текущего.
- Не перезагружает плейлист после каждого сегмента — снижает нагрузку.

### 2.2. Схемы catch-up
Определяются по исходному URL:
- “shift” (параметры `utc=` или `lutc=`),
- “append” (`offset=` или `utcstart=`),
- “flussonic” (`-timeshift_rel-` в пути),
- Или обычный VOD (без модификации).
После исчерпания сегментов формируется новый URL (если поддерживается).

### 2.3. Параметры пакетной выдачи
- “VOD Limit segments on startup” (vod-start) — начальный “рывок” (первая порция сегментов в первом окне).
- “VOD Limit segments in progress” (vod-process) — стартовая порция в последующих окнах.
- “VOD segments queue Step” (vod-queue-step) — сколько сегментов добавлять за цикл после исчерпания рывка.
Создаёт быстрый старт и затем равномерную загрузку.

### 2.4. Адаптивная пауза (Local VOD)
Между партиями система:
- Считает устойчивую “среднюю” длительность (медиана + высокий перцентиль).
- Поддерживает сглаженное значение заполнения.
- Следит за EMA отношения “время скачивания / длительность” (замедления сети).
- Включает “steady mode” при серии медленных сегментов.
- Мягко притормаживает при слишком большом буфере (ждёт до снижения).

### 2.5. Защита (Local VOD)
Включает smart-подобные проверки (отрицательный буфер, зависшие сегменты) плюс:
- Защита пустых окон: несколько подряд пустых — остановка.
- Сброс нумерации: если новое окно начинается “сначала”, логирует и переходит к началу окна.

### 2.6. Примеры логов (Local VOD)
- `<< Local VOD: next enqueue adaptive in X.XXs (seg=... buf=.../cap=...)`
- `VOD local: advancing window url -> ...`
- `VOD local: numbering reset/no forward segments...`
- `VOD local: empty window after advance, closing stream.`
- Аналогичные предупреждения о буфере и сегментах, как в Smart.

---

## 3. Gap Threshold и ранняя остановка

### 3.1. Назначение
В режимах без smart (segment/targetduration/default) бессмысленно ждать бесконечно при отсутствии новых сегментов. Порог gap — максимум “тишины”. Превышен → поток завершается. В smart эта величина используется как часть одной негативной проверки.

### 3.2. Вычисление (упрощённо)
Если `hls-segment-queue-threshold` > 0:
1. Базовое значение = максимум из:
   - Минимум 5с,
   - targetduration (если есть),
   - Среднее последних до 3 сегментов (или длительность последнего).
2. Умножить на коэффициент → порог.
3. Если новых сегментов нет дольше порога → остановка с предупреждением.

### 3.3. Отличия в Smart
Smart не полагается на gap для обычного планирования. Но:
- Эта же длительность участвует в “третьей” проверке: буфер непрерывно отрицателен дольше порога → остановка.
- Другие smart-условия (зависший сегмент, повторные минусы) могут сработать раньше.

### 3.4. Логи (Gap)
- `=> No new segments in playlist for more than X.XXs. Stopping...`

---

## 4. Соединения и закрытие

### 4.1. Close segment connection (hls-segment-conn-close)
Назначение:
- Добавляет `Connection: close` к HTTP-запросам сегментов/ключей/плейлистов.
Полезно при проблемных keep-alive (сервер/прокси “зависает”).

Плюсы:
- Меньше застрявших соединений.
Минусы:
- Дополнительные накладные расходы (установка TCP/TLS).
Включайте при непонятных зависаниях загрузок.

### 4.2. `hls-close-async`
Назначение:
- Ускоряет завершение стрима без блокировки основного потока.
Поведение:
- Закрытие запускается в отдельном потоке.
- Делает “fast abort”: отменяет незавершённые скачивания, чистит кеши, освобождает память.
- Логи “закрытия потоков” фильтруются, чтобы не засорять вывод.

Используйте, если много параллельных стримов или важна отзывчивость UI. По умолчанию включено.

---

## 5. Справочник логов

| Фрагмент лога | Значение |
|---------------|----------|
| `<< Planning Reload [smart]... mode=growth` | Низкий буфер; ускоряем опрос. |
| `<< Planning Reload [smart]... mode=slow` | Буфер высокий; замедляем опрос. |
| `+ Segment N complete (time=... retries=R)` | Сегмент загружен; R — сколько было повторов. |
| `Partial/incomplete segment N ... retrying...` | Частичный сбой сети; идёт дозагрузка. |
| `Segment N exceeded its duration ... Stopping...` | Застревание; защитная остановка. |
| `Negative buffer event #K` | Буфер снова минусовой. |
| `Buffer deficit exceeded last segment length ...` | Серьёзное смещение; остановка. |
| `=> No new segments ... Stopping...` | Порог тишины (gap) превышен. |
| `Local VOD: next enqueue adaptive in X.XXs` | Адаптивная пауза между партиями. |
| `LARGE JUMP: skipped ... segments` | Пропуск (разрыв нумерации). |
| `Filtering out segments and pausing stream output` | Сегменты отфильтрованы, вывод приостановлен. |
| `Retry fetch failed for segment N` | Последняя попытка не удалась. |
| `VOD local: advancing window url -> ...` | Переход к следующему окну. |
| `VOD local: empty window after advance...` | Новое окно пустое — завершение. |

---

## 6. Практические советы

- Частые остановки в smart → проверьте источник, попробуйте `targetduration` для диагностики.
- Частые partial/retry → нестабильная сеть; попробуйте `hls-segment-conn-close`.
- Высокая задержка сети → увеличьте `live-buffer-mult`.
- Нужна минимальная задержка → уменьшите `live-buffer-mult` (риск фризов).
- Local VOD: настройте `vod-start`, `vod-process`, `vod-queue-step` для баланса между скоростью старта и ровной загрузкой.

---

## 7. Итог

Smart Live и Local VOD повышают устойчивость, снижая фризы и лишние запросы. Пороги разрывов и защитные условия предотвращают “вечное ожидание” при проблемах источника. Опции соединений и асинхронного закрытия дают дополнительную управляемость и скорость освобождения ресурсов. Логи — прозрачная “панель приборов”: почти каждое адаптивное решение логируется и понятно гадательно.

Приятной эксплуатации и стабильного потока!